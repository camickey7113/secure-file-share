import java.nio.charset.StandardCharsets;
import java.util.*;

import javax.crypto.Mac;
import javax.sound.sampled.AudioFormat.Encoding;


public class Message implements java.io.Serializable {    
    // the command the Client is attempting to execute (e.g. “upload”)
    private String command;
    // a user token
    private Token token;
    // byte representation of the token signed with the AS public key
    private byte[] signature;
    // the content being exchanged (e.g. a file, if the command is “upload”)
    private ArrayList<Object> stuff;
    // the counter mechanism (detailed in T5)
    private int counter;
    /*
    byte representation of an HMAC generated by command, and counter
    and a symmetric key shared between the two communicating servers
    */
    private byte[] hmac;
    
    // Message Constructors
    public Message(String cmd, Token token, ArrayList<Object> stuff){
        this.command = cmd;
        this.token = token;
        this.signature = null;
        this.stuff = stuff;
        this.counter = 0;
    }

    public Message(String cmd, Token token, byte[] signature, ArrayList<Object> stuff){
        this.command = cmd;
        this.token = token;
        this.signature = signature;
        this.stuff = stuff;
        this.counter = 0;
    }


    // Getters
    public String getCommand() {
        return command;
    }

    public Token getToken() {
        return token;
    }

    public ArrayList<Object> getStuff() {
        return stuff;
    }

    public byte[] getSignature() {
        return signature;
    }

    public int getCounter() {
        return counter;
    }

    public byte[] getHMAC() {
        return hmac;
    }

    // Setters
    public void setCommand(String cmd) {
        this.command = cmd;
    }

    public void setToken(Token token) {
        this.token = token;
    }

    public void setSignature(byte[] signature) {
        this.signature = signature;
    }
    
    public boolean addStuff(Object item) {
        return stuff.add(item);
    }

    // deprecated because you should never have to update the counter
    @Deprecated
    public void setCounter(int n) {
        this.counter = n;
    }

    public void setHMAC(byte[] sessionID, byte[] key) {
        this.hmac = generateHMAC(sessionID, key);
    }

    // Generates an HMAC using the command, counter, sessionID, and a key
    public byte[] generateHMAC(byte[] sessionID, byte[] key) {
        // generate string from command, counter, and session ID
        String str = command + ":" + counter + ":" + sessionID;

        java.security.Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        try {
            // Initialize HMAC with SHA-256
            Mac hmac = new HMac(new SHA256Digest());
            byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8);
            hmac.init(new KeyParameter(keyBytes));

            // Process the message
            byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);
            hmac.update(messageBytes, 0, messageBytes.length);
            
            // Generate the output
            byte[] output = new byte[hmac.getMacSize()];
            hmac.doFinal(output, 0);

            // --------------------------------------------------------------

            var hmac2 = new HMac(new Sha256Digest());
            hmac2.Init(new KeyParameter(Encoding.UTF8.GetBytes(key)));
            byte[] result = new byte[hmac2.GetMacSize()];
            byte[] bytes = Encoding.UTF8.GetBytes(text);

            hmac.BlockUpdate(bytes, 0, bytes.Length);
            hmac.DoFinal(result, 0);

            return result;
        } catch (Exception e) {
            throw new RuntimeException("Error generating HMAC: ", e);
        }
    }

    // Regenerates the HMAC using the required components and checks it against the current HMAC.
    // Returns false if there is no existing HMAC or if there is a mismatch
    public boolean checkHMAC(byte[] sessionID, byte[] key) {
        if (this.hmac == null) return false;
        return (Arrays.equals(this.hmac, generateHMAC(sessionID, key)));
    }


    // managing the stuff list
    public boolean removeItem(Object item) {
        return stuff.remove(item);
    }
    
    public void removeAll() {
        stuff.clear();
    }

}