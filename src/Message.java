import java.nio.charset.StandardCharsets;
import java.util.*;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.sound.sampled.AudioFormat.Encoding;

import org.bouncycastle.jce.provider.BouncyCastleProvider;


public class Message implements java.io.Serializable {    
    // the command the Client is attempting to execute (e.g. “upload”)
    private String command;
    // a user token
    private Token token;
    // byte representation of the token signed with the AS public key
    private byte[] signature;
    // the content being exchanged (e.g. a file, if the command is “upload”)
    private ArrayList<Object> stuff;
    // the counter mechanism (detailed in T5)
    private int counter;
    /*
    byte representation of an HMAC generated by command, and counter
    and a symmetric key shared between the two communicating servers
    */
    private byte[] hmac;
    // groupkeys
    private GroupKey groupKey;

    static {
        java.security.Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    }
    
    // Message Constructors
    public Message(String cmd, Token token, ArrayList<Object> stuff){
        this.command = cmd;
        this.token = token;
        this.signature = null;
        this.stuff = stuff;
        this.counter = 0;
    }

    public Message(String cmd, Token token, byte[] signature, ArrayList<Object> stuff){
        this.command = cmd;
        this.token = token;
        this.signature = signature;
        this.stuff = stuff;
        this.counter = 0;
    }

    // Getters
    public String getCommand() {
        return command;
    }

    public Token getToken() {
        return token;
    }

    public ArrayList<Object> getStuff() {
        return stuff;
    }

    public byte[] getSignature() {
        return signature;
    }

    public int getCounter() {
        return counter;
    }

    public byte[] getHMAC() {
        return hmac;
    }

    public GroupKey getGroupKey() {
        return groupKey;
    }

    // Setters
    public void setCommand(String cmd) {
        this.command = cmd;
    }

    public void setToken(Token token) {
        this.token = token;
    }

    public void setSignature(byte[] signature) {
        this.signature = signature;
    }
    
    public boolean addStuff(Object item) {
        return stuff.add(item);
    }

    public void setCounter(int n) {
        this.counter = n;
    }

    public void setHMAC(SecretKey hmacKey) {
        this.hmac = generateHMAC(hmacKey);
    }

    public void setGroupKey(GroupKey groupKey){
        this.groupKey = groupKey;
    }

    // Generates an HMAC using the command, counter, sessionID, and a key
    public byte[] generateHMAC(SecretKey hmacKey) {
        // generate string from command, counter, and session ID
        String str = command + ":" + counter; // THIS IS GONNA CRASHHHH - need to convert byte[] to String? Maybe? There's no errors at compile-time

        try {
            Mac mac = Mac.getInstance("HmacSHA256", BouncyCastleProvider.PROVIDER_NAME);
            // SecretKeySpec  mKey = new SecretKeySpec(key, "AES");
            mac.init(hmacKey);
            byte[] messageBytes = str.getBytes(StandardCharsets.UTF_8);
            mac.update(messageBytes, 0, messageBytes.length);
            byte[] output = new byte[mac.getMacLength()];
            mac.doFinal(output);
            return output;

        } catch (Exception e) {
            throw new RuntimeException("Error generating HMAC: ", e);
        }
    }

    // Regenerates the HMAC using the required components and checks it against the current HMAC.
    // Returns false if there is no existing HMAC or if there is a mismatch
    public boolean checkHMAC(SecretKey key) {
        if (this.hmac == null) return false;
        return (Arrays.equals(this.hmac, generateHMAC(key)));
    }

    // managing the stuff list
    public boolean removeItem(Object item) {
        return stuff.remove(item);
    }
    
    public void removeAll() {
        stuff.clear();
    }

}